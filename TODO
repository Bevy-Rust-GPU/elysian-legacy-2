* Refactor domain types as trait impls
  * Semantically similar to context, i.e. a set of types
  * Will avoid having to implement combinators over (Distance, D)
  * Should allow replacing (DistanceF32, (GradientF32, ()) with PosDistGrad
    * Feels like Input / Field / Output taking multiple values may complicate this

  DONE: Attempted, but ended up creating type aliases for lists,
        as Combine subtypes need to pattern-match an ADT in order to deconflict their impls

* Elide Input / Output / Field wrapping for API purposes
  * Structs still need to exist for ADT purposes
  * Need an ADT lifting function that can be called inside the Shr impl

  DONE: Implemented via shape builder wrapper and Shr operator

* Formalize rasterize, ascii, image, viuer into new ADT subtype
  * Interpreter is the wrong term
  * Semantically a Context -> Context operation
    * Similar to domain-lifted Input / Output / Field functions,
      and composable with them
  * Supertype of all existing ADT ops?
    * Devil's advocate says this is overcomplicated and should be omitted
      in favour of simple function composition
      * However, it's still useful as ADT for the following reasons:
        * Chaining multiple actions within a context (i.e. nesting inside Shape, Combine)
        * Use of output within a context
          * ex:
            Texture mapping via Raster + Uv + Color
            Conversion to a mesh for LOD / optimization purposes under software rasterization
            Rendering generated ascii as distance field characters
            Using texture lookup as an alternative to domain evaluation
        * Breaking specific entries out of a context to leave the ADT and continue via simple composition

  DONE: Implemented Modify as an ADT unit, but not useful for rasterize etc
        since they evaluate an ADT rather than modifying a context.
        However, this realizes Get, Set and related lifted functions as Modify subtypes.

* Make Combine operation types symbolic
  * Lift via trait, similar to domain functions
  * Allows the ADT to remain a Free structure
  * Allows formalization of interpreters over free structure

  DONE: Combine ops are now lifted into the register machine interpreter via the LiftCombine trait

* Strengthen Input / Field / Output encoding
  * Create specific traits to replace Domain
    * LiftInput / LiftOutput / LiftField
    * Allows relating of open symbol types to closed ADT wrappers
  * Feels like it relates to a prospective output type encoding,
    since the promise is that A flows through Inputs,
    is transformed into B by Field, then flows through Outputs
  
  DONE: Encoded via LiftAdt, since lifting into a wrapper and lifting into functions are distinct

* Parameter substitution for symbolic ADT inner types
  * Use functions instead of literals
    * Ex. Isosurface(Const(0.2)) instead of Isosurface(0.2)
  * Lift to context functions and evaluate as part of overall graph
  * Using functions allows arbitrary value transformation before use as input
  * Opens the door to functional reactive programming
    * Animation system by using time as a parameter
  * Can use Tagged types for named variables
    * ex. Tagged<ProjectionMatrix, Mat4> for raymarching, corresponding GetF<ProjectionMatrix>
    * May be able to replace DistanceF32 etc with true symbol types

  DONE: Parameters are now functions, and get lifted via LiftParam during evaluation

* ADT de/serialization via serde
  * Opens the door to an Elysian file type, FFI, etc

  DONE: Derived Serialize / Deserialize for all ADT structs and symbols

* Investigate generalized chaining framework based on Do / AdtBuilder
  * Could act as a viable alternative to Haskell's customizable operators
  * Use a single operator, or perhaps two to control associativity (i.e. Shl / Shr)
  * Use operation symbol types (ex. DoFmap, DoApply) to represent binary ops
  * Symbol types become a wrapper when operated on
  * Wrapper type applies binary op when operated on
  * Terminating type (ex. Done) to morph between wrappers or unwrap

  DONE: Implemented in t_funk::r#do

* Refactor operator overloads as Do subtypes

  DONE: Operator overloads replaced with Do-able trait operators

* Refactor ADT to split Input / Field / Output into a sub-ADT
  * Currently impractical to implement Monad etc
  * Input / Field / Output is essentially equivalent to Modify
  * May need to give the outer ADT a terminating type to satisfy Mempty

  DONE: Input / Field / Output are now resposible for enforcing their A -> B semantics

* Create macros to simplify creating identical impls for multiple ADT subclasses
  
  DONE: define_adt for defining multiple structs with the same attributes,
        impl_adt for creating identical impls for multiple structs at once

* Create dual of function attribute macro to lift functions to the type level
  * i.e. Annotate a generic function, get a trait, FunctionF and FunctionT types
  * Will also need a free-standing version to lift functions defined in other crates

  DONE: Implemented as t_funk::macros::lift, refactored existing impls accordingly

* Try to unify lifting functions so monad instance is transparent
  * i.e. Should be able to chain from ADT -> List -> ADT
         Should also be able to compose ADTs with a single Do function
  
  DONE: All ADT elements now lift in a unified manner.
        In addition, various core rust types can now lift transparently into paramters.

* Finalize Semigroup / Monoid instances for ADT

  DONE: Formalized Compose impls with doctests, so Semigroup and Monoid
        strictly offload to other classes, so are in and of themselves robust.

* Finalize Monad instance for ADT

  DONE: ADT can freely chain to a const list representation and back

* Investigate Applicative instance for ADT

  DONE: Implemented based on list instance, using Modify for Pure

* Refactor * -> Sequence composition to match on compatible types
  
  DONE: Implemented bounds on existing traits

* Investigate monad transformers
  * Using independently-provable building blocks seems idiomatic to FP
  * May be able to reduce explicit / arbitrary ADT into fundamental typeclasses and instances

  DONE: Seems useful for extending an explicit ADT with the properties of a given monad,
        but potentially clunky if used with primitives like Tagged as a first-class building block.
        Explicit ADT seems preferable for the sake of readable API,
        but a primitive building block approach has potential for IR transformations.

* Replace tuple-based vectors / points with glam structs

  DONE: Refactored associated wrappers to be unary, integrated glam types

* Rework Input / Field / Output as a free-standing abstraction,
  host inside Modify when lifting to ADT
  * Already semantically equavalent to Modify - i.e. a C -> C - just with stronger encoding

  DONE: Implementing double-lifting to go from symbol -> Shape -> ADT,
        refactored composition accordingly

* Investigate Alternative and MonadPlus
  * Combine subtypes seem like they have a strong relation to these typeclasses

  DONE: Useful to know about, but only useful in cases where the binary op is intuitive.
        This would be the case for Combine if it was just <A, B>,
        but being parametrized over an additional F prevents it.


* Refactor context lifting to be transparent
  * Currently occurs inside LiftDomainFunctions, which is called by LiftDomains
    * This makes it specific to shapes, when it should be specific to context modifiers
  * Run is the intuitive place to put it, but doesn't line up with existing idioms
    * GetContext / SetContext specifically
      * These specialize around using the t-funk Get / Set functions directly
    * Looked at splitting Run into Read / Write / Modify, but doesn't make sense.
      * Read is equivalent to piping the output of Get into some function
      * Write would have nowhere to get parameters from except the context
    * Primary goal here is to allow general modifiers the same
      automatic context lifting interface as shape functions,
      rather than having to use the Get / Set traits directly
      * In which case, reintroducing a Modify newtype as a sibling of Shape
        may be the best solution, since the levels of wrapping are currently lopsided
        w.r.t. open types.

  SKIPPED: Introducing Modify solves the underlying issue without needing
           to burden the ADT with full compositional responsibility.
           This is still desirable, but can be approached as a set of
           smaller more granular tasks later.


* Reimplement Modify as a sibling to Shape, Get and Set
  * Should be able to auto-lift functions to context in the same way

  DONE: Modify now lifts symbols and functions, and functions to domain functions

* Rework rasterize, ascii, viuer as functions that operate on a context
  * Intent is to make them part of the ADT, since rasterize takes a base context
  * Store Raster in context and operate on it instead of simply producing it
  * Modify(Rasterize(SHAPE_ADT)) << Modify(Ascii) << Modify(PrintLn)?
    * Would require storing String in context to hold Ascii output
    * Likewise with image types for Viuer
    * Notably, this would be a separate domain-specific context in each case
    * Allows composition, i.e. sampling the raster as a texture using the UVs of some parent shape
      * However, this would only make sense if statically evaluating the raster or providing a pre-baked texture,
        since evaluating the child ADT directly from the parent would produce better results.
    * As with the existing code, this layer should be free, i.e. symbol-based
      * Allows exotic interpretations like rasterizing into a texture,
        then feeding it into a shader rendering a shape ADT
        that would normally consume the rasterization as child data

 DONE: Evaluators have been factored out in favor of Modify subtypes that compose evaluable ADTs

* Formalize Combine behaviour
  * Boolean shouldn't care about any evaluation downstream of Distance
  * Instead, it should evaluate Distance, then call one of two functions
    * Downstream evaluations can be provided via EvaluateF::<D>::default().prefix(...)

 DONE: Combiners now take (A, B, C, FA, FB) where A / B are distance eval closures,
      FA / FB are full eval closures, and any composed functions (ex. Lt, Gt) are lifted to read from a context

* Distance + Color evaluation
  
  DONE: Color can be injected for a given field without needing domain impls,
        working as a passthrough w.r.t. boolean etc.

* R&D for proxy application
  * Semantically, this is a combine operation that
    evaluates shapes A and B, and replaces or blends
    some subset of shape B's context into shape A's context
  * In theory, this is a superset of distance boolean / bounding operators
    i.e. Replacing distance in the case of regular boolean,
         and blending it in the case of smooth boolean
    * Could generalize Boolean to arbitrary domain types, make combine functions composable
      * How to handle dragging the rest of the context through?
        * Seems like an additional semantic on top of the binary op
          i.e. whichever succeeds also brings the rest of its context

 DONE: Now iterating on solutions

* Refactor contexts to allow polymorphism
  
  DONE: All contexts can now freely morph their generic types

=======================================================================================================================

* Replace Shape subtypes with context move semantics
    * i.e. Context modifiers remove values from the context, then optionally replace them
    * Shape subtypes are the wrong abstraction for program correctness
      * Obstructs correct programs that involve wrappers, ex. Scale(...)
    * Program correctness should be enforced by Get<T> bounds in interpreters,
      rather than directly through EDSL types
    * Implementation:
      * Introduce a Moves associated type to ModifyFunction / DomainFunction,
        which is similar to Inputs, but specifies which types will be
        removed from the context before outputs are applied
      * This allows fanout copy semantics to be retained,
        which solves various dependency issues between domain functions
        (ex. explicit domain ordering)
      * In addition, multiple domain functions trying to move the same data
        will produce a compiler error, further strengthening the abstraction
      * Probably better to avoid introducing Moves,
        and instead create an aggregate list of types to remove
        * Enforces move semantics as standard, but avoids multiple-removes,
          or cases where one domain has to be authoritative over moving,
          thus invalidating the other domains if used in isolation.
        * How to do this?
          * Lack of negative impls makes it impossible to to 'is not'
            for an open set (i.e. trait implementors)
          * Best bet is probably to reuse the context's set-like properties,
            since it already contains type holes for all relevant data
            * Take an empty context (via a new Empty trait), set each input on it at the type level
              to produce a to-remove set type, then call Remove<T> on the input context once for each of its generic types
              * Missing types will no-op, on account of calling Remove<()>
              * Shouldn't be too hefty to introduce apply traits for sets
                i.e. ApplyRemove would remove all of set A's elements from set B,
                     ApplySet would insert them, and so on.
                * These seem like boolean operations - probably worth some research into the Set typeclass
                * Seems generalizable for convenience (i.e. map function F over sets A and B to produce set C)

* Factor out Input / Field / Output and elide Modify
  * ModifyFunction and DomainFunction have identical signatures,
    and not enough meaningful differences to justify being distinct

* Formalize wrapping operations
  * Operations that need control before and after child evaluation,
    or those that need a manual evaluation strategy
    ex. Scale requires a reciprocal multiply after shape evaluation for correctness
        Local differencing averages multiple evaluations
  * Implement as wrapper types that sit between Run and its subtypes
    ex. adt() << Scale(adt() << Circle(1.0) >> Done) >> Done
        adt() << DeriveNormals {
            shape: adt() << Circle(1.0) >> Done) >> Done,
            k: 0.01,
        }
  * Scale(Inner) should LiftAdt to Then(ScalePosition, Then(Inner, Then(InverseScaleDistance, AdtEnd)))

* Further generalization for Boolean and SmoothBoolean
  * Combiner / blending functions should be (C, C) -> C rather than (C, C) -> bool

* Composability for combination functions
  * Need to be able to define per-context-member combination strategies
    ex. Boolean distance, lerp color with k = 0.5, always take normal from left side, etc
  * Similar strategy to domain function composition
    * Fanout A / B contexts across lifted (C, C) -> C functions to create setters,
      compose setters, then apply setters to context
    * Seems like it may be generalizable in some sense,
      though the difference in signatures necessitates abstraction

* Reconsider replacing Then with Combine<A, B, ComposeL> or such
  * Really, Then is just Combine with an implicit combinator

* Amend Combine typeclass impls
  * Foldr / Foldl / Mappend should produce a single value for each Combine,
    rather than aggregating its A / B types as per Then.
  * To wit, Combine should call F(A, B) in order to produce this single value
    * Should allow for proper behaviour, possibly open the door to ADT-based evaluation
  * How to make this work for current usage?
    * Could make the combiner function a constructor for LiftEvaluateCombine

* Look into convenience functions for composing monadic structure
  * RepeatM etc, various utilities from Haskell's base libraries
  * Bare minimum, whatever is needed to recreate the diagrams example that inspired Elysian

* Abstract over multi-frame evaluation
  * ex:
    Generating a series of images for ascii / viuer printing
    Generating an animated GIF for viuer printing
  * Can use a parameter function to retrieve time from context and parametrize
  * This is higher-order operation over image-generating contexts
    * Uses another distinct context of its own, likely containing a list / array of outputs

* Investigate refactoring register machine interpreter into a State monad impl
  * Effectively equivalent - drags a state (i.e. context) through a chain of functions,
    which can be lifted to operate on the state
  * May need a StateT transformer to make this ergonomic
    * Maybe not - need to puzzle out the types involved and see what's ideal
  * If any notable code remains after refactor,
    it should be split into a free-standing register machine abstraction

* Simple lighting model for rendering 2D fields
  * Concrete case for use of normal and color

* Improve functions macro
  * Should be able to cover all cases present in t-funk and elysian

* Revisit autogenerated type suffixes
  * FooT conflicts with the T suffix for monad transformers
    * Perhaps better as FooR or FooO to indicate that it represents return / output

* Consider extending impl_adt! to resemble match syntax
  * pub struct Elysian {
        Foo | Bar | Baz => {
        } where
            Foo: Clone,
        Nil => {}
    }
  * Move existing Foo | Bar | Baz parse to the left of => and the corresponding impl to the right,
    parse multiple blocks
  * Unsure about where clause, needs to be per-block, but seems unergonomic

* Improve lift macro to use PhantomData for handling non-bound types
  * Still a valid Function impl, since a self receiver is not needed

* Better list abstraction for t-funk
  * Need a unified set of interfaces that can be implemented by HList and nested tuples
  * Ideally also regular tuples, though that may raise conflicts between approaches

* Haskell diagrams R&D
  * Lots of food for thought in the documentation
    * https://archives.haskell.org/projects.haskell.org/diagrams/doc/quickstart.html
  * Attribute injection
    * Currently handled by Set, but largely unproven
  * Local origins
  * Envelope-based layout
    * Alignment (i.e. envelope fit vs plane)
  * Snug fit via raycasting
  * Monoid composition
  * Points
  * Segments
  * Lines
  * Splines
  * Loops
  * Trails
  * Paths
  * Arrows

* Formalize interpretation of free structure
  * Existing type-level register machine behaviour is an interpreter
  * Could this be unified under Interpret and Interpreter traits?
    * Traversable is likely relevant here
  * Alternate interpreters:
    * Dynamic structuring
      * Convert ADT into a type-erased value-level equivalent (ex. dyn / impl Trait)
        * Useful for runtime editing,
          though may not be mandatory if strongly-typed recursive control flow is viable
    * EDSL graph visualizer
      * Create a new EDSL visualizing the graph as UI primitives
    * Graph optimizer
    * Bevy hierarchy generator
      * Interpret boolean union as breaking a child out of its parent hierarchy
    * Static evaluation
      * Pre-evaluate expensive operations
        * ex. Layout:
          Replace a Combine<A, B, AxialFit> with Combine<Shape<Translate, A>, Shape<Translate, B>, Union>
          * Where AxialFit is semantically equivalent to raycast-based layout from Haskell diagrams
          * This raises the question of how AxialFit relates to Union
            * Suggests the need for composable Combine subtypes?
              * Devil's advocate says this may be overkill,
                since ex. horizontal layout aims to avoid overlap
              * However, making it compositional strengthens semantics
                and eases implementation for coupled cases
                (i.e. via type alias or function call wrapping)
          * Code should be shareable between runtime and static evaluation

* ADT parsing via nom
  * Opens the door to creating a specialized CLI REPL
